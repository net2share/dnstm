package shadowsocks

import (
	"bufio"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/net2share/dnstm/internal/system"
	slipstreamPkg "github.com/net2share/dnstm/internal/tunnel/slipstream"
)

const (
	ConfigDir     = "/etc/shadowsocks-slipstream"
	ConfigFile    = "shadowsocks.conf" // dnstm config
	SSConfigFile  = "config.json"      // shadowsocks config
	Port          = "5302"
	BinaryName    = "ssserver"
	ServiceName   = "shadowsocks-slipstream"
	ServiceUser   = system.DnstmUser
	SlipstreamBin = "slipstream-server"
	DefaultMethod = "aes-256-gcm"
)

// Config holds the Shadowsocks server configuration.
type Config struct {
	Domain   string
	Password string
	Method   string
	CertFile string
	KeyFile  string
}

// SSConfig is the Shadowsocks JSON configuration format.
type SSConfig struct {
	Server     string `json:"server"`
	ServerPort int    `json:"server_port"`
	Password   string `json:"password"`
	Method     string `json:"method"`
	Mode       string `json:"mode"`
	Plugin     string `json:"plugin"`
	PluginOpts string `json:"plugin_opts"`
	PluginMode string `json:"plugin_mode"`
}

// Load loads the Shadowsocks configuration from file.
func Load() (*Config, error) {
	configPath := filepath.Join(ConfigDir, ConfigFile)

	file, err := os.Open(configPath)
	if err != nil {
		if os.IsNotExist(err) {
			return &Config{
				Method: DefaultMethod,
			}, nil
		}
		return nil, err
	}
	defer file.Close()

	config := &Config{
		Method: DefaultMethod,
	}

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.Trim(strings.TrimSpace(parts[1]), "\"")

		switch key {
		case "DOMAIN":
			config.Domain = value
		case "PASSWORD":
			config.Password = value
		case "METHOD":
			config.Method = value
		case "CERT_FILE":
			config.CertFile = value
		case "KEY_FILE":
			config.KeyFile = value
		}
	}

	return config, scanner.Err()
}

// Save saves the Shadowsocks configuration to file.
func (c *Config) Save() error {
	if err := os.MkdirAll(ConfigDir, 0750); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	configPath := filepath.Join(ConfigDir, ConfigFile)

	content := fmt.Sprintf(`# shadowsocks-slipstream configuration
# Generated by dnstm

DOMAIN="%s"
PASSWORD="%s"
METHOD="%s"
CERT_FILE="%s"
KEY_FILE="%s"
`, c.Domain, c.Password, c.Method, c.CertFile, c.KeyFile)

	if err := os.WriteFile(configPath, []byte(content), 0640); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// WriteSSConfig writes the Shadowsocks JSON configuration file.
func (c *Config) WriteSSConfig() error {
	if err := os.MkdirAll(ConfigDir, 0750); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	pluginOpts := fmt.Sprintf("domain=%s;cert=%s;key=%s", c.Domain, c.CertFile, c.KeyFile)

	ssConfig := SSConfig{
		Server:     "0.0.0.0",
		ServerPort: 5302,
		Password:   c.Password,
		Method:     c.Method,
		Mode:       "tcp_only",
		Plugin:     "/usr/local/bin/" + SlipstreamBin,
		PluginOpts: pluginOpts,
		PluginMode: "tcp_only",
	}

	configPath := filepath.Join(ConfigDir, SSConfigFile)
	data, err := json.MarshalIndent(ssConfig, "", "    ")
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0640); err != nil {
		return fmt.Errorf("failed to write shadowsocks config: %w", err)
	}

	return nil
}

// GeneratePassword generates a secure random password (32 bytes base64).
func GeneratePassword() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", fmt.Errorf("failed to generate random password: %w", err)
	}
	return base64.StdEncoding.EncodeToString(bytes), nil
}

// Exists checks if the Shadowsocks configuration exists.
func Exists() bool {
	configPath := filepath.Join(ConfigDir, ConfigFile)
	_, err := os.Stat(configPath)
	return err == nil
}

// RemoveAll removes the Shadowsocks configuration directory.
func RemoveAll() {
	os.RemoveAll(ConfigDir)
}

// GetCertFilenames returns the certificate and key file paths for a domain.
// Stores certs in /etc/shadowsocks-slipstream/ (separate from standalone Slipstream).
func GetCertFilenames(domain string) (certFile, keyFile string) {
	sanitized := strings.ReplaceAll(domain, ".", "_")
	certFile = filepath.Join(ConfigDir, sanitized+"_cert.pem")
	keyFile = filepath.Join(ConfigDir, sanitized+"_key.pem")
	return
}

// GetFormattedConfig returns the configuration as a formatted string for display.
func (c *Config) GetFormattedConfig() string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("Domain:     %s\n", c.Domain))
	b.WriteString(fmt.Sprintf("Method:     %s\n", c.Method))
	b.WriteString(fmt.Sprintf("Password:   %s\n", c.Password))
	b.WriteString(fmt.Sprintf("Port:       %s\n", Port))
	b.WriteString(fmt.Sprintf("Plugin:     %s\n", SlipstreamBin))
	b.WriteString(fmt.Sprintf("Cert File:  %s\n", c.CertFile))
	b.WriteString(fmt.Sprintf("Key File:   %s\n", c.KeyFile))
	return b.String()
}

// FormatFingerprint formats a fingerprint for display (with colons).
// Delegates to slipstream package for consistency.
func FormatFingerprint(fingerprint string) string {
	return slipstreamPkg.FormatFingerprint(fingerprint)
}
